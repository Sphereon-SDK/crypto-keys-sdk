/*
 * Crypto Keys
 * The Crypto Keys API allows you to import, create and work with symmetric and asymmetric keys and certificates to sign/verify digest values, encrypt/decrypt input, or hash and sign input values. The benefit is that you don't have to store secret keys in your application.  The API has an integration with Azure KeyVault, allowing you to store keys, secrets and certificates in FIPS 140-2 Level 2 validated Hardware Security Modules (HSM). The key will never leave the HSM, making it really secure, especially if you combine it with IP whitelisting      Interactive testing: A web based test console is available in the <a href=\"https://store.sphereon.com\">Sphereon API Store</a>
 *
 * OpenAPI spec version: 0.9
 * Contact: dev@sphereon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.sphereon.sdk.crypto.keys.api;

import com.sphereon.sdk.crypto.keys.handler.ApiException;
import com.sphereon.sdk.crypto.keys.model.KeyDecryptRequest;
import com.sphereon.sdk.crypto.keys.model.KeyDecryptResponse;
import com.sphereon.sdk.crypto.keys.model.KeyEncryptRequest;
import com.sphereon.sdk.crypto.keys.model.KeyEncryptResponse;
import com.sphereon.sdk.crypto.keys.model.KeySignRequest;
import com.sphereon.sdk.crypto.keys.model.KeySignResponse;
import com.sphereon.sdk.crypto.keys.model.KeyVerifyRequest;
import com.sphereon.sdk.crypto.keys.model.KeyVerifyResponse;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for ContentApi
 */
@Ignore
public class ContentApiTest {

    private final ContentApi api = new ContentApi();

    
    /**
     * Decrypt value
     *
     * Decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is the reverse of the encrypt operation. This operation applies to asymmetric and symmetric keys since it uses the private portion of the key.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void decryptUsingKeyTest() throws ApiException {
        String config = null;
        String name = null;
        String version = null;
        KeyDecryptRequest request = null;
        KeyDecryptResponse response = api.decryptUsingKey(config, name, version, request);

        // TODO: test validations
    }
    
    /**
     * Encrypt value
     *
     * Encrypts a sequence of bytes using an encryption key. This operation is only strictly necessary for symmetric keys since encryption with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void encryptUsingKeyTest() throws ApiException {
        String config = null;
        String name = null;
        String version = null;
        KeyEncryptRequest request = null;
        KeyEncryptResponse response = api.encryptUsingKey(config, name, version, request);

        // TODO: test validations
    }
    
    /**
     * Create signature
     *
     * Creates a signature from a digest using a key. This operation is applicable to asymmetric and symmetric keys, since this operation uses the private portion of the key. Please note that the input needs to be a hash using a hash algorithm that fits the JsonWebKeySignatureAlgorithm, meaning SHA-256, SHA-384 or SHA-512
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signUsingKeyTest() throws ApiException {
        String config = null;
        String name = null;
        String version = null;
        KeySignRequest request = null;
        KeySignResponse response = api.signUsingKey(config, name, version, request);

        // TODO: test validations
    }
    
    /**
     * Verify signature
     *
     * Verifies a signature using a key. This operation is applicable to assymetric and symmetric keys. It is not strictly necessary for asymmetric keys, since signature verification can be performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void verifyUsingKeyTest() throws ApiException {
        String config = null;
        String name = null;
        String version = null;
        KeyVerifyRequest request = null;
        KeyVerifyResponse response = api.verifyUsingKey(config, name, version, request);

        // TODO: test validations
    }
    
}
