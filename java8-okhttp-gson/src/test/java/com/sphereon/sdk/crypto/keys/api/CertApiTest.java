/*
 * Crypto Keys
 * The Crypto Keys API allows you to import, create and work with symmetric and asymmetric keys and certificates to sign/verify digest values, encrypt/decrypt input, or hash and sign input values. The benefit is that you don't have to store secret keys in your application.  The API has an integration with Azure KeyVault, allowing you to store keys, secrets and certificates in FIPS 140-2 Level 2 validated Hardware Security Modules (HSM). The key will never leave the HSM, making it really secure, especially if you combine it with IP whitelisting      Interactive testing: A web based test console is available in the <a href=\"https://store.sphereon.com\">Sphereon API Store</a>
 *
 * OpenAPI spec version: 0.9
 * Contact: dev@sphereon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.sphereon.sdk.crypto.keys.api;

import com.sphereon.sdk.crypto.keys.handler.ApiException;
import com.sphereon.sdk.crypto.keys.model.CertificateBundleResponse;
import com.sphereon.sdk.crypto.keys.model.CertificateMetadataListResponse;
import com.sphereon.sdk.crypto.keys.model.CreateCertificateRequest;
import com.sphereon.sdk.crypto.keys.model.CreateCertificateResponse;
import com.sphereon.sdk.crypto.keys.model.DeletedCertificateBundleResponse;
import com.sphereon.sdk.crypto.keys.model.ImportCertificateRequest;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for CertApi
 */
@Ignore
public class CertApiTest {

    private final CertApi api = new CertApi();

    
    /**
     * Create certificate
     *
     * Creates a new certificate. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void createCertTest() throws ApiException {
        String config = null;
        CreateCertificateRequest certificateRequest = null;
        CreateCertificateResponse response = api.createCert(config, certificateRequest);

        // TODO: test validations
    }
    
    /**
     * Delete certificate
     *
     * Deletes a certificate
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deleteCertTest() throws ApiException {
        String config = null;
        String name = null;
        DeletedCertificateBundleResponse response = api.deleteCert(config, name);

        // TODO: test validations
    }
    
    /**
     * Get certificate info
     *
     * Gets information about a certificate
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getCertTest() throws ApiException {
        String config = null;
        String name = null;
        String version = null;
        CertificateBundleResponse response = api.getCert(config, name, version);

        // TODO: test validations
    }
    
    /**
     * Import certificate
     *
     * Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void importCertTest() throws ApiException {
        String config = null;
        ImportCertificateRequest request = null;
        CreateCertificateResponse response = api.importCert(config, request);

        // TODO: test validations
    }
    
    /**
     * List certificates metadata information
     *
     * Gets a list of all certiciate metadata
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void listCertsTest() throws ApiException {
        String config = null;
        CertificateMetadataListResponse response = api.listCerts(config);

        // TODO: test validations
    }
    
}
