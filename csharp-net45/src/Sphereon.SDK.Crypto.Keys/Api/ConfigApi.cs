/* 
 * Crypto Keys
 *
 * The Crypto Keys API allows you to import, create and work with symmetric and asymmetric keys and certificates to sign/verify digest values, encrypt/decrypt input, or hash and sign input values. The benefit is that you don't have to store secret keys in your application.  The API has an integration with Azure KeyVault, allowing you to store keys, secrets and certificates in FIPS 140-2 Level 2 validated Hardware Security Modules (HSM). The key will never leave the HSM, making it really secure, especially if you combine it with IP whitelisting      Interactive testing: A web based test console is available in the <a href=\"https://store.sphereon.com\">Sphereon API Store</a>
 *
 * OpenAPI spec version: 0.9
 * Contact: dev@sphereon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Sphereon.SDK.Crypto.Keys.Client;
using Sphereon.SDK.Crypto.Keys.Model;

namespace Sphereon.SDK.Crypto.Keys.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IConfigApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Create a new Configuration
        /// </summary>
        /// <remarks>
        /// Create a new crypto key configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The configuration request</param>
        /// <returns>ConfigurationResponse</returns>
        ConfigurationResponse CreateConfiguration (CreateConfigurationRequest request);

        /// <summary>
        /// Create a new Configuration
        /// </summary>
        /// <remarks>
        /// Create a new crypto key configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The configuration request</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        ApiResponse<ConfigurationResponse> CreateConfigurationWithHttpInfo (CreateConfigurationRequest request);
        /// <summary>
        /// Delete Configuration
        /// </summary>
        /// <remarks>
        /// Delete an existing configuration. As a protection this can only be done using the configuration Id and this not the name
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config id</param>
        /// <returns>ConfigurationResponse</returns>
        ConfigurationResponse DeleteConfiguration (string config);

        /// <summary>
        /// Delete Configuration
        /// </summary>
        /// <remarks>
        /// Delete an existing configuration. As a protection this can only be done using the configuration Id and this not the name
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config id</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        ApiResponse<ConfigurationResponse> DeleteConfigurationWithHttpInfo (string config);
        /// <summary>
        /// Get Configuration
        /// </summary>
        /// <remarks>
        /// Get existing configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config name</param>
        /// <returns>ConfigurationResponse</returns>
        ConfigurationResponse GetConfiguration (string config);

        /// <summary>
        /// Get Configuration
        /// </summary>
        /// <remarks>
        /// Get existing configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config name</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        ApiResponse<ConfigurationResponse> GetConfigurationWithHttpInfo (string config);
        /// <summary>
        /// Update Configuration
        /// </summary>
        /// <remarks>
        /// Update an existing configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The updated configuration request</param>
        /// <returns>ConfigurationResponse</returns>
        ConfigurationResponse UpdateConfiguration (string config, UpdateConfigurationRequest request);

        /// <summary>
        /// Update Configuration
        /// </summary>
        /// <remarks>
        /// Update an existing configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The updated configuration request</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        ApiResponse<ConfigurationResponse> UpdateConfigurationWithHttpInfo (string config, UpdateConfigurationRequest request);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Create a new Configuration
        /// </summary>
        /// <remarks>
        /// Create a new crypto key configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The configuration request</param>
        /// <returns>Task of ConfigurationResponse</returns>
        System.Threading.Tasks.Task<ConfigurationResponse> CreateConfigurationAsync (CreateConfigurationRequest request);

        /// <summary>
        /// Create a new Configuration
        /// </summary>
        /// <remarks>
        /// Create a new crypto key configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The configuration request</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> CreateConfigurationAsyncWithHttpInfo (CreateConfigurationRequest request);
        /// <summary>
        /// Delete Configuration
        /// </summary>
        /// <remarks>
        /// Delete an existing configuration. As a protection this can only be done using the configuration Id and this not the name
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config id</param>
        /// <returns>Task of ConfigurationResponse</returns>
        System.Threading.Tasks.Task<ConfigurationResponse> DeleteConfigurationAsync (string config);

        /// <summary>
        /// Delete Configuration
        /// </summary>
        /// <remarks>
        /// Delete an existing configuration. As a protection this can only be done using the configuration Id and this not the name
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config id</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> DeleteConfigurationAsyncWithHttpInfo (string config);
        /// <summary>
        /// Get Configuration
        /// </summary>
        /// <remarks>
        /// Get existing configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config name</param>
        /// <returns>Task of ConfigurationResponse</returns>
        System.Threading.Tasks.Task<ConfigurationResponse> GetConfigurationAsync (string config);

        /// <summary>
        /// Get Configuration
        /// </summary>
        /// <remarks>
        /// Get existing configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config name</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> GetConfigurationAsyncWithHttpInfo (string config);
        /// <summary>
        /// Update Configuration
        /// </summary>
        /// <remarks>
        /// Update an existing configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The updated configuration request</param>
        /// <returns>Task of ConfigurationResponse</returns>
        System.Threading.Tasks.Task<ConfigurationResponse> UpdateConfigurationAsync (string config, UpdateConfigurationRequest request);

        /// <summary>
        /// Update Configuration
        /// </summary>
        /// <remarks>
        /// Update an existing configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The updated configuration request</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> UpdateConfigurationAsyncWithHttpInfo (string config, UpdateConfigurationRequest request);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ConfigApi : IConfigApi
    {
        private Sphereon.SDK.Crypto.Keys.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConfigApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ConfigApi(String basePath)
        {
            this.Configuration = new Configuration(new ApiClient(basePath));

            ExceptionFactory = Sphereon.SDK.Crypto.Keys.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConfigApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ConfigApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Sphereon.SDK.Crypto.Keys.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Sphereon.SDK.Crypto.Keys.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public Dictionary<String, String> DefaultHeader()
        {
            return this.Configuration.DefaultHeader;
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Create a new Configuration Create a new crypto key configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The configuration request</param>
        /// <returns>ConfigurationResponse</returns>
        public ConfigurationResponse CreateConfiguration (CreateConfigurationRequest request)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = CreateConfigurationWithHttpInfo(request);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a new Configuration Create a new crypto key configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The configuration request</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        public ApiResponse< ConfigurationResponse > CreateConfigurationWithHttpInfo (CreateConfigurationRequest request)
        {
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ConfigApi->CreateConfiguration");

            var localVarPath = "/manage/configs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

        /// <summary>
        /// Create a new Configuration Create a new crypto key configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The configuration request</param>
        /// <returns>Task of ConfigurationResponse</returns>
        public async System.Threading.Tasks.Task<ConfigurationResponse> CreateConfigurationAsync (CreateConfigurationRequest request)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = await CreateConfigurationAsyncWithHttpInfo(request);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a new Configuration Create a new crypto key configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The configuration request</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> CreateConfigurationAsyncWithHttpInfo (CreateConfigurationRequest request)
        {
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ConfigApi->CreateConfiguration");

            var localVarPath = "/manage/configs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

        /// <summary>
        /// Delete Configuration Delete an existing configuration. As a protection this can only be done using the configuration Id and this not the name
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config id</param>
        /// <returns>ConfigurationResponse</returns>
        public ConfigurationResponse DeleteConfiguration (string config)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = DeleteConfigurationWithHttpInfo(config);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Delete Configuration Delete an existing configuration. As a protection this can only be done using the configuration Id and this not the name
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config id</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        public ApiResponse< ConfigurationResponse > DeleteConfigurationWithHttpInfo (string config)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ConfigApi->DeleteConfiguration");

            var localVarPath = "/manage/configs/{config}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

        /// <summary>
        /// Delete Configuration Delete an existing configuration. As a protection this can only be done using the configuration Id and this not the name
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config id</param>
        /// <returns>Task of ConfigurationResponse</returns>
        public async System.Threading.Tasks.Task<ConfigurationResponse> DeleteConfigurationAsync (string config)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = await DeleteConfigurationAsyncWithHttpInfo(config);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Delete Configuration Delete an existing configuration. As a protection this can only be done using the configuration Id and this not the name
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config id</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> DeleteConfigurationAsyncWithHttpInfo (string config)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ConfigApi->DeleteConfiguration");

            var localVarPath = "/manage/configs/{config}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

        /// <summary>
        /// Get Configuration Get existing configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config name</param>
        /// <returns>ConfigurationResponse</returns>
        public ConfigurationResponse GetConfiguration (string config)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = GetConfigurationWithHttpInfo(config);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Configuration Get existing configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config name</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        public ApiResponse< ConfigurationResponse > GetConfigurationWithHttpInfo (string config)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ConfigApi->GetConfiguration");

            var localVarPath = "/manage/configs/{config}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

        /// <summary>
        /// Get Configuration Get existing configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config name</param>
        /// <returns>Task of ConfigurationResponse</returns>
        public async System.Threading.Tasks.Task<ConfigurationResponse> GetConfigurationAsync (string config)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = await GetConfigurationAsyncWithHttpInfo(config);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Configuration Get existing configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config name</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> GetConfigurationAsyncWithHttpInfo (string config)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ConfigApi->GetConfiguration");

            var localVarPath = "/manage/configs/{config}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

        /// <summary>
        /// Update Configuration Update an existing configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The updated configuration request</param>
        /// <returns>ConfigurationResponse</returns>
        public ConfigurationResponse UpdateConfiguration (string config, UpdateConfigurationRequest request)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = UpdateConfigurationWithHttpInfo(config, request);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update Configuration Update an existing configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The updated configuration request</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        public ApiResponse< ConfigurationResponse > UpdateConfigurationWithHttpInfo (string config, UpdateConfigurationRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ConfigApi->UpdateConfiguration");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ConfigApi->UpdateConfiguration");

            var localVarPath = "/manage/configs/{config}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

        /// <summary>
        /// Update Configuration Update an existing configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The updated configuration request</param>
        /// <returns>Task of ConfigurationResponse</returns>
        public async System.Threading.Tasks.Task<ConfigurationResponse> UpdateConfigurationAsync (string config, UpdateConfigurationRequest request)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = await UpdateConfigurationAsyncWithHttpInfo(config, request);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update Configuration Update an existing configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The updated configuration request</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> UpdateConfigurationAsyncWithHttpInfo (string config, UpdateConfigurationRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ConfigApi->UpdateConfiguration");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ConfigApi->UpdateConfiguration");

            var localVarPath = "/manage/configs/{config}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

    }
}
