/* 
 * Crypto Keys
 *
 * The Crypto Keys API allows you to import, create and work with symmetric and asymmetric keys and certificates to sign/verify digest values, encrypt/decrypt input, or hash and sign input values. The benefit is that you don't have to store secret keys in your application.  The API has an integration with Azure KeyVault, allowing you to store keys, secrets and certificates in FIPS 140-2 Level 2 validated Hardware Security Modules (HSM). The key will never leave the HSM, making it really secure, especially if you combine it with IP whitelisting      Interactive testing: A web based test console is available in the <a href=\"https://store.sphereon.com\">Sphereon API Store</a>
 *
 * OpenAPI spec version: 0.9
 * Contact: dev@sphereon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Sphereon.SDK.Crypto.Keys.Client;
using Sphereon.SDK.Crypto.Keys.Model;

namespace Sphereon.SDK.Crypto.Keys.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICertApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Create certificate
        /// </summary>
        /// <remarks>
        /// Creates a new certificate. 
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="certificateRequest">The create certificate request</param>
        /// <returns>CreateCertificateResponse</returns>
        CreateCertificateResponse CreateCert (string config, CreateCertificateRequest certificateRequest);

        /// <summary>
        /// Create certificate
        /// </summary>
        /// <remarks>
        /// Creates a new certificate. 
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="certificateRequest">The create certificate request</param>
        /// <returns>ApiResponse of CreateCertificateResponse</returns>
        ApiResponse<CreateCertificateResponse> CreateCertWithHttpInfo (string config, CreateCertificateRequest certificateRequest);
        /// <summary>
        /// Delete certificate
        /// </summary>
        /// <remarks>
        /// Deletes a certificate
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <returns>DeletedCertificateBundleResponse</returns>
        DeletedCertificateBundleResponse DeleteCert (string config, string name);

        /// <summary>
        /// Delete certificate
        /// </summary>
        /// <remarks>
        /// Deletes a certificate
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <returns>ApiResponse of DeletedCertificateBundleResponse</returns>
        ApiResponse<DeletedCertificateBundleResponse> DeleteCertWithHttpInfo (string config, string name);
        /// <summary>
        /// Get certificate info
        /// </summary>
        /// <remarks>
        /// Gets information about a certificate
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <returns>CertificateBundleResponse</returns>
        CertificateBundleResponse GetCert (string config, string name, string version);

        /// <summary>
        /// Get certificate info
        /// </summary>
        /// <remarks>
        /// Gets information about a certificate
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <returns>ApiResponse of CertificateBundleResponse</returns>
        ApiResponse<CertificateBundleResponse> GetCertWithHttpInfo (string config, string name, string version);
        /// <summary>
        /// Import certificate
        /// </summary>
        /// <remarks>
        /// Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The import certificate request</param>
        /// <returns>CreateCertificateResponse</returns>
        CreateCertificateResponse ImportCert (string config, ImportCertificateRequest request);

        /// <summary>
        /// Import certificate
        /// </summary>
        /// <remarks>
        /// Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The import certificate request</param>
        /// <returns>ApiResponse of CreateCertificateResponse</returns>
        ApiResponse<CreateCertificateResponse> ImportCertWithHttpInfo (string config, ImportCertificateRequest request);
        /// <summary>
        /// List certificates metadata information
        /// </summary>
        /// <remarks>
        /// Gets a list of all certiciate metadata
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <returns>CertificateMetadataListResponse</returns>
        CertificateMetadataListResponse ListCerts (string config);

        /// <summary>
        /// List certificates metadata information
        /// </summary>
        /// <remarks>
        /// Gets a list of all certiciate metadata
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <returns>ApiResponse of CertificateMetadataListResponse</returns>
        ApiResponse<CertificateMetadataListResponse> ListCertsWithHttpInfo (string config);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Create certificate
        /// </summary>
        /// <remarks>
        /// Creates a new certificate. 
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="certificateRequest">The create certificate request</param>
        /// <returns>Task of CreateCertificateResponse</returns>
        System.Threading.Tasks.Task<CreateCertificateResponse> CreateCertAsync (string config, CreateCertificateRequest certificateRequest);

        /// <summary>
        /// Create certificate
        /// </summary>
        /// <remarks>
        /// Creates a new certificate. 
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="certificateRequest">The create certificate request</param>
        /// <returns>Task of ApiResponse (CreateCertificateResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreateCertificateResponse>> CreateCertAsyncWithHttpInfo (string config, CreateCertificateRequest certificateRequest);
        /// <summary>
        /// Delete certificate
        /// </summary>
        /// <remarks>
        /// Deletes a certificate
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <returns>Task of DeletedCertificateBundleResponse</returns>
        System.Threading.Tasks.Task<DeletedCertificateBundleResponse> DeleteCertAsync (string config, string name);

        /// <summary>
        /// Delete certificate
        /// </summary>
        /// <remarks>
        /// Deletes a certificate
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <returns>Task of ApiResponse (DeletedCertificateBundleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedCertificateBundleResponse>> DeleteCertAsyncWithHttpInfo (string config, string name);
        /// <summary>
        /// Get certificate info
        /// </summary>
        /// <remarks>
        /// Gets information about a certificate
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <returns>Task of CertificateBundleResponse</returns>
        System.Threading.Tasks.Task<CertificateBundleResponse> GetCertAsync (string config, string name, string version);

        /// <summary>
        /// Get certificate info
        /// </summary>
        /// <remarks>
        /// Gets information about a certificate
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <returns>Task of ApiResponse (CertificateBundleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CertificateBundleResponse>> GetCertAsyncWithHttpInfo (string config, string name, string version);
        /// <summary>
        /// Import certificate
        /// </summary>
        /// <remarks>
        /// Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The import certificate request</param>
        /// <returns>Task of CreateCertificateResponse</returns>
        System.Threading.Tasks.Task<CreateCertificateResponse> ImportCertAsync (string config, ImportCertificateRequest request);

        /// <summary>
        /// Import certificate
        /// </summary>
        /// <remarks>
        /// Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The import certificate request</param>
        /// <returns>Task of ApiResponse (CreateCertificateResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreateCertificateResponse>> ImportCertAsyncWithHttpInfo (string config, ImportCertificateRequest request);
        /// <summary>
        /// List certificates metadata information
        /// </summary>
        /// <remarks>
        /// Gets a list of all certiciate metadata
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <returns>Task of CertificateMetadataListResponse</returns>
        System.Threading.Tasks.Task<CertificateMetadataListResponse> ListCertsAsync (string config);

        /// <summary>
        /// List certificates metadata information
        /// </summary>
        /// <remarks>
        /// Gets a list of all certiciate metadata
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <returns>Task of ApiResponse (CertificateMetadataListResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CertificateMetadataListResponse>> ListCertsAsyncWithHttpInfo (string config);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class CertApi : ICertApi
    {
        private Sphereon.SDK.Crypto.Keys.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="CertApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CertApi(String basePath)
        {
            this.Configuration = new Configuration(new ApiClient(basePath));

            ExceptionFactory = Sphereon.SDK.Crypto.Keys.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CertApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public CertApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Sphereon.SDK.Crypto.Keys.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Sphereon.SDK.Crypto.Keys.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public Dictionary<String, String> DefaultHeader()
        {
            return this.Configuration.DefaultHeader;
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Create certificate Creates a new certificate. 
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="certificateRequest">The create certificate request</param>
        /// <returns>CreateCertificateResponse</returns>
        public CreateCertificateResponse CreateCert (string config, CreateCertificateRequest certificateRequest)
        {
             ApiResponse<CreateCertificateResponse> localVarResponse = CreateCertWithHttpInfo(config, certificateRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create certificate Creates a new certificate. 
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="certificateRequest">The create certificate request</param>
        /// <returns>ApiResponse of CreateCertificateResponse</returns>
        public ApiResponse< CreateCertificateResponse > CreateCertWithHttpInfo (string config, CreateCertificateRequest certificateRequest)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling CertApi->CreateCert");
            // verify the required parameter 'certificateRequest' is set
            if (certificateRequest == null)
                throw new ApiException(400, "Missing required parameter 'certificateRequest' when calling CertApi->CreateCert");

            var localVarPath = "/{config}/certs/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (certificateRequest != null && certificateRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(certificateRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = certificateRequest; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateCert", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CreateCertificateResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CreateCertificateResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(CreateCertificateResponse)));
        }

        /// <summary>
        /// Create certificate Creates a new certificate. 
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="certificateRequest">The create certificate request</param>
        /// <returns>Task of CreateCertificateResponse</returns>
        public async System.Threading.Tasks.Task<CreateCertificateResponse> CreateCertAsync (string config, CreateCertificateRequest certificateRequest)
        {
             ApiResponse<CreateCertificateResponse> localVarResponse = await CreateCertAsyncWithHttpInfo(config, certificateRequest);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create certificate Creates a new certificate. 
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="certificateRequest">The create certificate request</param>
        /// <returns>Task of ApiResponse (CreateCertificateResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CreateCertificateResponse>> CreateCertAsyncWithHttpInfo (string config, CreateCertificateRequest certificateRequest)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling CertApi->CreateCert");
            // verify the required parameter 'certificateRequest' is set
            if (certificateRequest == null)
                throw new ApiException(400, "Missing required parameter 'certificateRequest' when calling CertApi->CreateCert");

            var localVarPath = "/{config}/certs/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (certificateRequest != null && certificateRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(certificateRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = certificateRequest; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateCert", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CreateCertificateResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CreateCertificateResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(CreateCertificateResponse)));
        }

        /// <summary>
        /// Delete certificate Deletes a certificate
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <returns>DeletedCertificateBundleResponse</returns>
        public DeletedCertificateBundleResponse DeleteCert (string config, string name)
        {
             ApiResponse<DeletedCertificateBundleResponse> localVarResponse = DeleteCertWithHttpInfo(config, name);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Delete certificate Deletes a certificate
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <returns>ApiResponse of DeletedCertificateBundleResponse</returns>
        public ApiResponse< DeletedCertificateBundleResponse > DeleteCertWithHttpInfo (string config, string name)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling CertApi->DeleteCert");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling CertApi->DeleteCert");

            var localVarPath = "/{config}/certs/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCert", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedCertificateBundleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DeletedCertificateBundleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedCertificateBundleResponse)));
        }

        /// <summary>
        /// Delete certificate Deletes a certificate
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <returns>Task of DeletedCertificateBundleResponse</returns>
        public async System.Threading.Tasks.Task<DeletedCertificateBundleResponse> DeleteCertAsync (string config, string name)
        {
             ApiResponse<DeletedCertificateBundleResponse> localVarResponse = await DeleteCertAsyncWithHttpInfo(config, name);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Delete certificate Deletes a certificate
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <returns>Task of ApiResponse (DeletedCertificateBundleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DeletedCertificateBundleResponse>> DeleteCertAsyncWithHttpInfo (string config, string name)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling CertApi->DeleteCert");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling CertApi->DeleteCert");

            var localVarPath = "/{config}/certs/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCert", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedCertificateBundleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (DeletedCertificateBundleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedCertificateBundleResponse)));
        }

        /// <summary>
        /// Get certificate info Gets information about a certificate
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <returns>CertificateBundleResponse</returns>
        public CertificateBundleResponse GetCert (string config, string name, string version)
        {
             ApiResponse<CertificateBundleResponse> localVarResponse = GetCertWithHttpInfo(config, name, version);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get certificate info Gets information about a certificate
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <returns>ApiResponse of CertificateBundleResponse</returns>
        public ApiResponse< CertificateBundleResponse > GetCertWithHttpInfo (string config, string name, string version)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling CertApi->GetCert");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling CertApi->GetCert");
            // verify the required parameter 'version' is set
            if (version == null)
                throw new ApiException(400, "Missing required parameter 'version' when calling CertApi->GetCert");

            var localVarPath = "/{config}/certs/{name}/{version}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (version != null) localVarPathParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCert", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CertificateBundleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CertificateBundleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(CertificateBundleResponse)));
        }

        /// <summary>
        /// Get certificate info Gets information about a certificate
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <returns>Task of CertificateBundleResponse</returns>
        public async System.Threading.Tasks.Task<CertificateBundleResponse> GetCertAsync (string config, string name, string version)
        {
             ApiResponse<CertificateBundleResponse> localVarResponse = await GetCertAsyncWithHttpInfo(config, name, version);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get certificate info Gets information about a certificate
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <returns>Task of ApiResponse (CertificateBundleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CertificateBundleResponse>> GetCertAsyncWithHttpInfo (string config, string name, string version)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling CertApi->GetCert");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling CertApi->GetCert");
            // verify the required parameter 'version' is set
            if (version == null)
                throw new ApiException(400, "Missing required parameter 'version' when calling CertApi->GetCert");

            var localVarPath = "/{config}/certs/{name}/{version}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (version != null) localVarPathParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCert", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CertificateBundleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CertificateBundleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(CertificateBundleResponse)));
        }

        /// <summary>
        /// Import certificate Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The import certificate request</param>
        /// <returns>CreateCertificateResponse</returns>
        public CreateCertificateResponse ImportCert (string config, ImportCertificateRequest request)
        {
             ApiResponse<CreateCertificateResponse> localVarResponse = ImportCertWithHttpInfo(config, request);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Import certificate Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The import certificate request</param>
        /// <returns>ApiResponse of CreateCertificateResponse</returns>
        public ApiResponse< CreateCertificateResponse > ImportCertWithHttpInfo (string config, ImportCertificateRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling CertApi->ImportCert");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling CertApi->ImportCert");

            var localVarPath = "/{config}/certs/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ImportCert", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CreateCertificateResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CreateCertificateResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(CreateCertificateResponse)));
        }

        /// <summary>
        /// Import certificate Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The import certificate request</param>
        /// <returns>Task of CreateCertificateResponse</returns>
        public async System.Threading.Tasks.Task<CreateCertificateResponse> ImportCertAsync (string config, ImportCertificateRequest request)
        {
             ApiResponse<CreateCertificateResponse> localVarResponse = await ImportCertAsyncWithHttpInfo(config, request);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Import certificate Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="request">The import certificate request</param>
        /// <returns>Task of ApiResponse (CreateCertificateResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CreateCertificateResponse>> ImportCertAsyncWithHttpInfo (string config, ImportCertificateRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling CertApi->ImportCert");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling CertApi->ImportCert");

            var localVarPath = "/{config}/certs/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ImportCert", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CreateCertificateResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CreateCertificateResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(CreateCertificateResponse)));
        }

        /// <summary>
        /// List certificates metadata information Gets a list of all certiciate metadata
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <returns>CertificateMetadataListResponse</returns>
        public CertificateMetadataListResponse ListCerts (string config)
        {
             ApiResponse<CertificateMetadataListResponse> localVarResponse = ListCertsWithHttpInfo(config);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List certificates metadata information Gets a list of all certiciate metadata
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <returns>ApiResponse of CertificateMetadataListResponse</returns>
        public ApiResponse< CertificateMetadataListResponse > ListCertsWithHttpInfo (string config)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling CertApi->ListCerts");

            var localVarPath = "/{config}/certs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListCerts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CertificateMetadataListResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CertificateMetadataListResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(CertificateMetadataListResponse)));
        }

        /// <summary>
        /// List certificates metadata information Gets a list of all certiciate metadata
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <returns>Task of CertificateMetadataListResponse</returns>
        public async System.Threading.Tasks.Task<CertificateMetadataListResponse> ListCertsAsync (string config)
        {
             ApiResponse<CertificateMetadataListResponse> localVarResponse = await ListCertsAsyncWithHttpInfo(config);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List certificates metadata information Gets a list of all certiciate metadata
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <returns>Task of ApiResponse (CertificateMetadataListResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CertificateMetadataListResponse>> ListCertsAsyncWithHttpInfo (string config)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling CertApi->ListCerts");

            var localVarPath = "/{config}/certs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListCerts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CertificateMetadataListResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CertificateMetadataListResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(CertificateMetadataListResponse)));
        }

    }
}
