/* 
 * Crypto Keys
 *
 * The Crypto Keys API allows you to import, create and work with symmetric and asymmetric keys and certificates to sign/verify digest values, encrypt/decrypt input, or hash and sign input values. The benefit is that you don't have to store secret keys in your application.  The API has an integration with Azure KeyVault, allowing you to store keys, secrets and certificates in FIPS 140-2 Level 2 validated Hardware Security Modules (HSM). The key will never leave the HSM, making it really secure, especially if you combine it with IP whitelisting      Interactive testing: A web based test console is available in the <a href=\"https://store.sphereon.com\">Sphereon API Store</a>
 *
 * OpenAPI spec version: 0.9
 * Contact: dev@sphereon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Sphereon.SDK.Crypto.Keys.Client;
using Sphereon.SDK.Crypto.Keys.Model;

namespace Sphereon.SDK.Crypto.Keys.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IContentApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Decrypt value
        /// </summary>
        /// <remarks>
        /// Decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is the reverse of the encrypt operation. This operation applies to asymmetric and symmetric keys since it uses the private portion of the key.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The decrypt request</param>
        /// <returns>KeyDecryptResponse</returns>
        KeyDecryptResponse DecryptUsingKey (string config, string name, string version, KeyDecryptRequest request);

        /// <summary>
        /// Decrypt value
        /// </summary>
        /// <remarks>
        /// Decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is the reverse of the encrypt operation. This operation applies to asymmetric and symmetric keys since it uses the private portion of the key.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The decrypt request</param>
        /// <returns>ApiResponse of KeyDecryptResponse</returns>
        ApiResponse<KeyDecryptResponse> DecryptUsingKeyWithHttpInfo (string config, string name, string version, KeyDecryptRequest request);
        /// <summary>
        /// Encrypt value
        /// </summary>
        /// <remarks>
        /// Encrypts a sequence of bytes using an encryption key. This operation is only strictly necessary for symmetric keys since encryption with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The encrypt request</param>
        /// <returns>KeyEncryptResponse</returns>
        KeyEncryptResponse EncryptUsingKey (string config, string name, string version, KeyEncryptRequest request);

        /// <summary>
        /// Encrypt value
        /// </summary>
        /// <remarks>
        /// Encrypts a sequence of bytes using an encryption key. This operation is only strictly necessary for symmetric keys since encryption with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The encrypt request</param>
        /// <returns>ApiResponse of KeyEncryptResponse</returns>
        ApiResponse<KeyEncryptResponse> EncryptUsingKeyWithHttpInfo (string config, string name, string version, KeyEncryptRequest request);
        /// <summary>
        /// Create signature
        /// </summary>
        /// <remarks>
        /// Creates a signature from a digest using a key. This operation is applicable to asymmetric and symmetric keys, since this operation uses the private portion of the key. Please note that the input needs to be a hash using a hash algorithm that fits the JsonWebKeySignatureAlgorithm, meaning SHA-256, SHA-384 or SHA-512
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The sign request</param>
        /// <returns>KeySignResponse</returns>
        KeySignResponse SignUsingKey (string config, string name, string version, KeySignRequest request);

        /// <summary>
        /// Create signature
        /// </summary>
        /// <remarks>
        /// Creates a signature from a digest using a key. This operation is applicable to asymmetric and symmetric keys, since this operation uses the private portion of the key. Please note that the input needs to be a hash using a hash algorithm that fits the JsonWebKeySignatureAlgorithm, meaning SHA-256, SHA-384 or SHA-512
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The sign request</param>
        /// <returns>ApiResponse of KeySignResponse</returns>
        ApiResponse<KeySignResponse> SignUsingKeyWithHttpInfo (string config, string name, string version, KeySignRequest request);
        /// <summary>
        /// Verify signature
        /// </summary>
        /// <remarks>
        /// Verifies a signature using a key. This operation is applicable to assymetric and symmetric keys. It is not strictly necessary for asymmetric keys, since signature verification can be performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The verify request</param>
        /// <returns>KeyVerifyResponse</returns>
        KeyVerifyResponse VerifyUsingKey (string config, string name, string version, KeyVerifyRequest request);

        /// <summary>
        /// Verify signature
        /// </summary>
        /// <remarks>
        /// Verifies a signature using a key. This operation is applicable to assymetric and symmetric keys. It is not strictly necessary for asymmetric keys, since signature verification can be performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The verify request</param>
        /// <returns>ApiResponse of KeyVerifyResponse</returns>
        ApiResponse<KeyVerifyResponse> VerifyUsingKeyWithHttpInfo (string config, string name, string version, KeyVerifyRequest request);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Decrypt value
        /// </summary>
        /// <remarks>
        /// Decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is the reverse of the encrypt operation. This operation applies to asymmetric and symmetric keys since it uses the private portion of the key.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The decrypt request</param>
        /// <returns>Task of KeyDecryptResponse</returns>
        System.Threading.Tasks.Task<KeyDecryptResponse> DecryptUsingKeyAsync (string config, string name, string version, KeyDecryptRequest request);

        /// <summary>
        /// Decrypt value
        /// </summary>
        /// <remarks>
        /// Decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is the reverse of the encrypt operation. This operation applies to asymmetric and symmetric keys since it uses the private portion of the key.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The decrypt request</param>
        /// <returns>Task of ApiResponse (KeyDecryptResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<KeyDecryptResponse>> DecryptUsingKeyAsyncWithHttpInfo (string config, string name, string version, KeyDecryptRequest request);
        /// <summary>
        /// Encrypt value
        /// </summary>
        /// <remarks>
        /// Encrypts a sequence of bytes using an encryption key. This operation is only strictly necessary for symmetric keys since encryption with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The encrypt request</param>
        /// <returns>Task of KeyEncryptResponse</returns>
        System.Threading.Tasks.Task<KeyEncryptResponse> EncryptUsingKeyAsync (string config, string name, string version, KeyEncryptRequest request);

        /// <summary>
        /// Encrypt value
        /// </summary>
        /// <remarks>
        /// Encrypts a sequence of bytes using an encryption key. This operation is only strictly necessary for symmetric keys since encryption with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The encrypt request</param>
        /// <returns>Task of ApiResponse (KeyEncryptResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<KeyEncryptResponse>> EncryptUsingKeyAsyncWithHttpInfo (string config, string name, string version, KeyEncryptRequest request);
        /// <summary>
        /// Create signature
        /// </summary>
        /// <remarks>
        /// Creates a signature from a digest using a key. This operation is applicable to asymmetric and symmetric keys, since this operation uses the private portion of the key. Please note that the input needs to be a hash using a hash algorithm that fits the JsonWebKeySignatureAlgorithm, meaning SHA-256, SHA-384 or SHA-512
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The sign request</param>
        /// <returns>Task of KeySignResponse</returns>
        System.Threading.Tasks.Task<KeySignResponse> SignUsingKeyAsync (string config, string name, string version, KeySignRequest request);

        /// <summary>
        /// Create signature
        /// </summary>
        /// <remarks>
        /// Creates a signature from a digest using a key. This operation is applicable to asymmetric and symmetric keys, since this operation uses the private portion of the key. Please note that the input needs to be a hash using a hash algorithm that fits the JsonWebKeySignatureAlgorithm, meaning SHA-256, SHA-384 or SHA-512
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The sign request</param>
        /// <returns>Task of ApiResponse (KeySignResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<KeySignResponse>> SignUsingKeyAsyncWithHttpInfo (string config, string name, string version, KeySignRequest request);
        /// <summary>
        /// Verify signature
        /// </summary>
        /// <remarks>
        /// Verifies a signature using a key. This operation is applicable to assymetric and symmetric keys. It is not strictly necessary for asymmetric keys, since signature verification can be performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The verify request</param>
        /// <returns>Task of KeyVerifyResponse</returns>
        System.Threading.Tasks.Task<KeyVerifyResponse> VerifyUsingKeyAsync (string config, string name, string version, KeyVerifyRequest request);

        /// <summary>
        /// Verify signature
        /// </summary>
        /// <remarks>
        /// Verifies a signature using a key. This operation is applicable to assymetric and symmetric keys. It is not strictly necessary for asymmetric keys, since signature verification can be performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The verify request</param>
        /// <returns>Task of ApiResponse (KeyVerifyResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<KeyVerifyResponse>> VerifyUsingKeyAsyncWithHttpInfo (string config, string name, string version, KeyVerifyRequest request);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ContentApi : IContentApi
    {
        private Sphereon.SDK.Crypto.Keys.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ContentApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ContentApi(String basePath)
        {
            this.Configuration = new Configuration(new ApiClient(basePath));

            ExceptionFactory = Sphereon.SDK.Crypto.Keys.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ContentApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ContentApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Sphereon.SDK.Crypto.Keys.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Sphereon.SDK.Crypto.Keys.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public Dictionary<String, String> DefaultHeader()
        {
            return this.Configuration.DefaultHeader;
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Decrypt value Decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is the reverse of the encrypt operation. This operation applies to asymmetric and symmetric keys since it uses the private portion of the key.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The decrypt request</param>
        /// <returns>KeyDecryptResponse</returns>
        public KeyDecryptResponse DecryptUsingKey (string config, string name, string version, KeyDecryptRequest request)
        {
             ApiResponse<KeyDecryptResponse> localVarResponse = DecryptUsingKeyWithHttpInfo(config, name, version, request);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Decrypt value Decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is the reverse of the encrypt operation. This operation applies to asymmetric and symmetric keys since it uses the private portion of the key.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The decrypt request</param>
        /// <returns>ApiResponse of KeyDecryptResponse</returns>
        public ApiResponse< KeyDecryptResponse > DecryptUsingKeyWithHttpInfo (string config, string name, string version, KeyDecryptRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ContentApi->DecryptUsingKey");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ContentApi->DecryptUsingKey");
            // verify the required parameter 'version' is set
            if (version == null)
                throw new ApiException(400, "Missing required parameter 'version' when calling ContentApi->DecryptUsingKey");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ContentApi->DecryptUsingKey");

            var localVarPath = "/{config}/keys/{name}/{version}/decrypt";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (version != null) localVarPathParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DecryptUsingKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KeyDecryptResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (KeyDecryptResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(KeyDecryptResponse)));
        }

        /// <summary>
        /// Decrypt value Decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is the reverse of the encrypt operation. This operation applies to asymmetric and symmetric keys since it uses the private portion of the key.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The decrypt request</param>
        /// <returns>Task of KeyDecryptResponse</returns>
        public async System.Threading.Tasks.Task<KeyDecryptResponse> DecryptUsingKeyAsync (string config, string name, string version, KeyDecryptRequest request)
        {
             ApiResponse<KeyDecryptResponse> localVarResponse = await DecryptUsingKeyAsyncWithHttpInfo(config, name, version, request);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Decrypt value Decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is the reverse of the encrypt operation. This operation applies to asymmetric and symmetric keys since it uses the private portion of the key.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The decrypt request</param>
        /// <returns>Task of ApiResponse (KeyDecryptResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KeyDecryptResponse>> DecryptUsingKeyAsyncWithHttpInfo (string config, string name, string version, KeyDecryptRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ContentApi->DecryptUsingKey");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ContentApi->DecryptUsingKey");
            // verify the required parameter 'version' is set
            if (version == null)
                throw new ApiException(400, "Missing required parameter 'version' when calling ContentApi->DecryptUsingKey");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ContentApi->DecryptUsingKey");

            var localVarPath = "/{config}/keys/{name}/{version}/decrypt";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (version != null) localVarPathParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DecryptUsingKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KeyDecryptResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (KeyDecryptResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(KeyDecryptResponse)));
        }

        /// <summary>
        /// Encrypt value Encrypts a sequence of bytes using an encryption key. This operation is only strictly necessary for symmetric keys since encryption with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The encrypt request</param>
        /// <returns>KeyEncryptResponse</returns>
        public KeyEncryptResponse EncryptUsingKey (string config, string name, string version, KeyEncryptRequest request)
        {
             ApiResponse<KeyEncryptResponse> localVarResponse = EncryptUsingKeyWithHttpInfo(config, name, version, request);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Encrypt value Encrypts a sequence of bytes using an encryption key. This operation is only strictly necessary for symmetric keys since encryption with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The encrypt request</param>
        /// <returns>ApiResponse of KeyEncryptResponse</returns>
        public ApiResponse< KeyEncryptResponse > EncryptUsingKeyWithHttpInfo (string config, string name, string version, KeyEncryptRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ContentApi->EncryptUsingKey");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ContentApi->EncryptUsingKey");
            // verify the required parameter 'version' is set
            if (version == null)
                throw new ApiException(400, "Missing required parameter 'version' when calling ContentApi->EncryptUsingKey");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ContentApi->EncryptUsingKey");

            var localVarPath = "/{config}/keys/{name}/{version}/encrypt";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (version != null) localVarPathParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("EncryptUsingKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KeyEncryptResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (KeyEncryptResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(KeyEncryptResponse)));
        }

        /// <summary>
        /// Encrypt value Encrypts a sequence of bytes using an encryption key. This operation is only strictly necessary for symmetric keys since encryption with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The encrypt request</param>
        /// <returns>Task of KeyEncryptResponse</returns>
        public async System.Threading.Tasks.Task<KeyEncryptResponse> EncryptUsingKeyAsync (string config, string name, string version, KeyEncryptRequest request)
        {
             ApiResponse<KeyEncryptResponse> localVarResponse = await EncryptUsingKeyAsyncWithHttpInfo(config, name, version, request);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Encrypt value Encrypts a sequence of bytes using an encryption key. This operation is only strictly necessary for symmetric keys since encryption with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the public key material.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The encrypt request</param>
        /// <returns>Task of ApiResponse (KeyEncryptResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KeyEncryptResponse>> EncryptUsingKeyAsyncWithHttpInfo (string config, string name, string version, KeyEncryptRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ContentApi->EncryptUsingKey");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ContentApi->EncryptUsingKey");
            // verify the required parameter 'version' is set
            if (version == null)
                throw new ApiException(400, "Missing required parameter 'version' when calling ContentApi->EncryptUsingKey");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ContentApi->EncryptUsingKey");

            var localVarPath = "/{config}/keys/{name}/{version}/encrypt";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (version != null) localVarPathParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("EncryptUsingKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KeyEncryptResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (KeyEncryptResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(KeyEncryptResponse)));
        }

        /// <summary>
        /// Create signature Creates a signature from a digest using a key. This operation is applicable to asymmetric and symmetric keys, since this operation uses the private portion of the key. Please note that the input needs to be a hash using a hash algorithm that fits the JsonWebKeySignatureAlgorithm, meaning SHA-256, SHA-384 or SHA-512
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The sign request</param>
        /// <returns>KeySignResponse</returns>
        public KeySignResponse SignUsingKey (string config, string name, string version, KeySignRequest request)
        {
             ApiResponse<KeySignResponse> localVarResponse = SignUsingKeyWithHttpInfo(config, name, version, request);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create signature Creates a signature from a digest using a key. This operation is applicable to asymmetric and symmetric keys, since this operation uses the private portion of the key. Please note that the input needs to be a hash using a hash algorithm that fits the JsonWebKeySignatureAlgorithm, meaning SHA-256, SHA-384 or SHA-512
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The sign request</param>
        /// <returns>ApiResponse of KeySignResponse</returns>
        public ApiResponse< KeySignResponse > SignUsingKeyWithHttpInfo (string config, string name, string version, KeySignRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ContentApi->SignUsingKey");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ContentApi->SignUsingKey");
            // verify the required parameter 'version' is set
            if (version == null)
                throw new ApiException(400, "Missing required parameter 'version' when calling ContentApi->SignUsingKey");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ContentApi->SignUsingKey");

            var localVarPath = "/{config}/keys/{name}/{version}/sign";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (version != null) localVarPathParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SignUsingKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KeySignResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (KeySignResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(KeySignResponse)));
        }

        /// <summary>
        /// Create signature Creates a signature from a digest using a key. This operation is applicable to asymmetric and symmetric keys, since this operation uses the private portion of the key. Please note that the input needs to be a hash using a hash algorithm that fits the JsonWebKeySignatureAlgorithm, meaning SHA-256, SHA-384 or SHA-512
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The sign request</param>
        /// <returns>Task of KeySignResponse</returns>
        public async System.Threading.Tasks.Task<KeySignResponse> SignUsingKeyAsync (string config, string name, string version, KeySignRequest request)
        {
             ApiResponse<KeySignResponse> localVarResponse = await SignUsingKeyAsyncWithHttpInfo(config, name, version, request);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create signature Creates a signature from a digest using a key. This operation is applicable to asymmetric and symmetric keys, since this operation uses the private portion of the key. Please note that the input needs to be a hash using a hash algorithm that fits the JsonWebKeySignatureAlgorithm, meaning SHA-256, SHA-384 or SHA-512
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The sign request</param>
        /// <returns>Task of ApiResponse (KeySignResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KeySignResponse>> SignUsingKeyAsyncWithHttpInfo (string config, string name, string version, KeySignRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ContentApi->SignUsingKey");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ContentApi->SignUsingKey");
            // verify the required parameter 'version' is set
            if (version == null)
                throw new ApiException(400, "Missing required parameter 'version' when calling ContentApi->SignUsingKey");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ContentApi->SignUsingKey");

            var localVarPath = "/{config}/keys/{name}/{version}/sign";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (version != null) localVarPathParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SignUsingKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KeySignResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (KeySignResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(KeySignResponse)));
        }

        /// <summary>
        /// Verify signature Verifies a signature using a key. This operation is applicable to assymetric and symmetric keys. It is not strictly necessary for asymmetric keys, since signature verification can be performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The verify request</param>
        /// <returns>KeyVerifyResponse</returns>
        public KeyVerifyResponse VerifyUsingKey (string config, string name, string version, KeyVerifyRequest request)
        {
             ApiResponse<KeyVerifyResponse> localVarResponse = VerifyUsingKeyWithHttpInfo(config, name, version, request);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Verify signature Verifies a signature using a key. This operation is applicable to assymetric and symmetric keys. It is not strictly necessary for asymmetric keys, since signature verification can be performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The verify request</param>
        /// <returns>ApiResponse of KeyVerifyResponse</returns>
        public ApiResponse< KeyVerifyResponse > VerifyUsingKeyWithHttpInfo (string config, string name, string version, KeyVerifyRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ContentApi->VerifyUsingKey");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ContentApi->VerifyUsingKey");
            // verify the required parameter 'version' is set
            if (version == null)
                throw new ApiException(400, "Missing required parameter 'version' when calling ContentApi->VerifyUsingKey");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ContentApi->VerifyUsingKey");

            var localVarPath = "/{config}/keys/{name}/{version}/verify";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (version != null) localVarPathParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("VerifyUsingKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KeyVerifyResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (KeyVerifyResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(KeyVerifyResponse)));
        }

        /// <summary>
        /// Verify signature Verifies a signature using a key. This operation is applicable to assymetric and symmetric keys. It is not strictly necessary for asymmetric keys, since signature verification can be performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The verify request</param>
        /// <returns>Task of KeyVerifyResponse</returns>
        public async System.Threading.Tasks.Task<KeyVerifyResponse> VerifyUsingKeyAsync (string config, string name, string version, KeyVerifyRequest request)
        {
             ApiResponse<KeyVerifyResponse> localVarResponse = await VerifyUsingKeyAsyncWithHttpInfo(config, name, version, request);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Verify signature Verifies a signature using a key. This operation is applicable to assymetric and symmetric keys. It is not strictly necessary for asymmetric keys, since signature verification can be performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
        /// </summary>
        /// <exception cref="Sphereon.SDK.Crypto.Keys.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="config">config</param>
        /// <param name="name">name</param>
        /// <param name="version">version</param>
        /// <param name="request">The verify request</param>
        /// <returns>Task of ApiResponse (KeyVerifyResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KeyVerifyResponse>> VerifyUsingKeyAsyncWithHttpInfo (string config, string name, string version, KeyVerifyRequest request)
        {
            // verify the required parameter 'config' is set
            if (config == null)
                throw new ApiException(400, "Missing required parameter 'config' when calling ContentApi->VerifyUsingKey");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling ContentApi->VerifyUsingKey");
            // verify the required parameter 'version' is set
            if (version == null)
                throw new ApiException(400, "Missing required parameter 'version' when calling ContentApi->VerifyUsingKey");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ContentApi->VerifyUsingKey");

            var localVarPath = "/{config}/keys/{name}/{version}/verify";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (config != null) localVarPathParams.Add("config", Configuration.ApiClient.ParameterToString(config)); // path parameter
            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (version != null) localVarPathParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("VerifyUsingKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KeyVerifyResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (KeyVerifyResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(KeyVerifyResponse)));
        }

    }
}
